'''
✓ Сортировка пузырьком
Один из простейших методов сортировки. Заключается в постепенном смещении элементов с большим значением в конец массива. 
Элементы последовательно сравниваются попарно, и если порядок в паре нарушен – меняются местами.

✓ Сортировка выбором
Алгоритм ищет наименьший элемент в текущем списке и производит обмен его значения со значением первой неотсортированной позиции. 
То же самое происходит со вторым элементом с наименьшим значением. Цикл повторяется до тех пор, 
пока все элементы не займут нужную последовательность.

✓ Быстрая сортировка
Считается одним из самых быстрых алгоритмов сортировки. Как и сортировка слиянием, 
работает по принципу «разделяй и властвуй». Временная сложность алгоритма может достигать O(n log n).

✓ Сортировка кучей (Пирамидальная сортировка)
Алгоритм выстраивает данные в виде двоичного дерева (двоичной кучи). 
Существует два варианта расположения элементов – max-heap (значение родителя больше значений потомков) и 
min-heap (значение родителя меньше значений потомков). Наибольший / наименьший элемент (в зависимости от типа) 
располагается в корне дерева. Он меняется местами с последним элементом кучи и помещается в конец массива. 
Размер кучи уменьшается на 1, после чего она перестраивается. Цикл повторяется, пока размер кучи больше 1.

✓ Сортировка вставками
Применяется для вставки элементов массива на «свое место». Сортировка вставками представляет 
собой простой метод сортировки и используется для раскладки колоды во время игры в бридж.

✓ Сортировка слиянием
Следует принципу «разделяй и властвуй», согласно которому массив данных разделяется на равные части,
которые сортируются по отдельности. После они сливаются, в результате получается отсортированный массив.
'''

                                 # Найти минимальное значение с помощью цикла

# На вход программе подаются вещественные числа, записанные через пробел. 
# Необходимо прочитать эти числа и сохранить в списке. 
# Затем, с помощью цикла for нужно найти наименьшее число в этом списке. 
# Полученный результат (минимальное число) вывести на экран.  
# Реализовать программу без использования функции min, max и сортировки.

# number = [float(i) for i in input().split()]
number = [8.6, 9.11, -4.567, -10.0, 1.45]     # -10
# number = [1.0, 2.0, 3.0, -3.0, -2.0, -1.0]    # -3
# number = [4.56, -5.67, -7.89, -3.23, 5.0]     # -7.89
# number = [4.56, 5.67, 7.89, 3.23, 5.0]        # 3,23

x = (float('inf'))  # бесконечность
result = number[0]

for i in range(len(number)):
    if number[i] < result:
        result = number[i]

print(result)

# for i in range(len(number)):
#     if number[i] < x:
#         x = number[i]
# print(x)

                                # Выполнить сортировку по возрастанию (пузырьковый метод)

# При первом проходе перебираем все соседние пары элементов и если значение предыдущего элемента (слева) больше значения следующего (справа), 
# то они меняются местами. (На рисунке 3 и 2 меняются местами). Следующая пара - это 3 и 6. 
# Они уже выстроены по возрастанию, поэтому ничего не делаем и переходим к следующей паре 6 и -1. 
# Меняем значения местами и видим, что на последнем месте находится максимальное значение 6, что нам и нужно.

# При втором проходе делаем все то же самое, но доходим до предпоследнего элемента, так как последнее значение 6 уже отсортировано. 
# На третьем проходе исключаем уже последние два элемента и так далее. 
# То есть, в этом алгоритме достаточно сделать N-1 проходов, где N - длина списка.

# Вот идея алгоритма сортировки всплывающего пузырька. 
# Реализуйте его для вводимого списка целых чисел. 
# Результат выведите на экран в виде последовательности чисел, записанных в одну строчку через пробел.

# number = [int(i) for i in input().split()]

number = [8, 11, -53, 2, 10, 11]    # -53 2 8 10 11 11

for i in range(len(number)-1):
    for j in range(len(number)-1-i):
        if number[j] > number[j+1]:   #  при замене на <, сортировка по убыванию
            number[j], number[j+1] = number[j+1], number[j]


print(*number)

                                        # Сортировка выбором
                                        
# Вначале мы рассматриваем первый элемент списка и ищем второй минимальный относительно первого элемента (включая и его). 
# На рисунке - это последний элемент со значением -1. 
# Затем, меняем местами первый и последний элементы. 
# Переходим ко второму элементу списка и повторяем эту же процедуру, но относительно второго элемента 
# (то есть, первый уже не рассматриваем). 
# На рисунке минимальный элемент - это 2, поэтому менять местами здесь ничего не нужно. 
# Переходим к 3-му элементы со значением 6. Относительно него находим минимальный элемент - это 3. 
# Меняем их местами. 
# Вот идея алгоритма сортировки выбором. Реализуйте его для сформированного списка целых чисел. 
# Результат выведите на экран в виде последовательности чисел, записанных в одну строчку через пробел.


for i in range(len(number)-1):             # Индекс `i` представляет текущую позицию, в которую мы будем помещать минимальный элемент
        m = i                       # m для отслеживания индекса минимального элемента в оставшейся части списка
        for j in range(i+1, len(number)):
            if number[j] < number[m]:
                m = j
        number[i], number[m] = number[m], number[i]

print(number)


                            # Сортировка слиянием

def merge_sort(nums):
    if len(nums) > 1:
        mid = len(nums)//2 # делим список на 2 равных
        left = nums[:mid]
        right = nums[mid:]
        merge_sort(left)
        merge_sort(right)                           
# • i — индекс в списке left,
# • j — индекс в списке right,
# • k — индекс в исходном списке nums, в который в конечном итоге нужно вставить все
# числа по порядку. 
    i = j = k = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            nums[k] = left[i]
            i+=1
        else:
            nums[k] = right[j]
            j+=1
            k+=1

    while j < len(right):
        nums[k] = right[j]
        j+=1
        k+=1
    while i < len(left):
        nums[k] = left[i]
        i+=1
        k+=1

# решение 2 сортировка слиянием 
def merge_two_list(a, b):
    c = []
    i = j = 0
    len_a, len_b = len(a), len(b)
    while i < len_a and j < len_b:
        if a[i] < b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1
    c += a[i:] + b[j:]
    return c    
        

def merge_sort(s):
    if len(s) == 1:
        return s
    middle = len(s) // 2
    left = merge_sort(s[:middle])
    right = merge_sort(s[middle:])
    return merge_two_list(left, right)

s = list(map(int, input().split()))
print(*merge_sort(s))


                                                        # имеется таблица
# Номер;Имя;Оценка;Зачет
# 1;Иванов;3;Да
# 2;Петров;2;Нет

# 1 преобразовать во вложенный кортеж
# ( ('Номер', 'Имя', 'Оценка', 'Зачет'), (1, 'Иванов', 3, 'Да'), (2, 'Петров', 2, 'Нет'), ... )
# сортировать кортеж в соответствии с Новый порядок: Имя; Зачет; Оценка; Номер

lst_in = ['Номер;Имя;Оценка;Зачет', '1;Портос;5;Да', '2;Арамис;3;Да', '3;Атос;4;Да', "4;д'Артаньян;2;Нет", '5;Балакирев;1;Нет']

# Преобразуем список строк в кортеж
data = tuple([tuple(line.split(';')) for line in lst_in])

# Извлекаем заголовки и данные
headers = data[0]
records = data[1:]

# Преобразуем цифры в int
data_ = []
for i in records:
     entry = (int(i[0]), i[1], int(i[2]), i[3])
     data_.append(entry)
records = tuple(data_)


# Новый порядок: Имя; Зачет; Оценка; Номер
new_order = ['Имя', 'Зачет', 'Оценка', 'Номер']
order_indices = [headers.index(col) for col in new_order]

# Переставляем столбцы в соответствии с новым порядком
sorted_records = [
    tuple(record[index] for index in order_indices) for record in records
]

# Формируем итоговый кортеж с заголовками и отсортированными данными
sorted_data = (tuple(new_order),) + tuple(sorted_records)

# Выводим результат
print(sorted_data)

                            # Сортировать список исходя из списка рангов

lst_in = [['Атос', 'лейтенант'], ['Портос', 'прапорщик'], ["д'Артаньян", 'капитан'], ['Арамис', 'лейтенант'], ['Балакирев', 'рядовой']] 

rank = ['рядовой', 'сержант', 'старшина', 'прапорщик', 'лейтенант',
        'капитан', 'майор', 'подполковник', 'полковник']

lst = sorted([i.split('=') for i in lst_in], key=lambda x: rank.index(x[1]))

