                # Убрать лишние пробелы с помощью вложенных циклов

#  На вход программе подается натуральное число N (то есть, положительное, целое). 
# Требуется его прочитать и создать двумерный (вложенный) список размером N x N элементов, 
# состоящий из всех единиц, а затем, в последний столбец записать пятерки. 
# Вывести этот список на экран в виде таблицы чисел, как показано в примере ниже.

n = 4
# Создаем вложенный(двумерный) список из 0
# zeros = []
# for i in range(n):
#     zeros.append([0]*n)
 
# # Меняем 0 на 1
# for i in range(n):
#     for j in range(n):
#         zeros[i][j] = 1

# Выводим на экран в виде таблицы
# for i in zeros:
#     print(zeros)

result = []

for i in range(n):
    result.append([0]*n)    # Создаем вложенный(двумерный) список из 0
    for j in range(n):
        result[i][j] = 1    # Меняем 0 на 1
    result[i][-1] = 5       # Меняем последнее значение во вложенном списке на 5

for i in result:
    print(*i)               # Выводим этот список на экран в виде таблицы чисел




                                # Найти соседей единицы

# На вход программе подается двумерный список размерностью 5 х 5 элементов, 
# состоящий из нулей и в некоторых позициях единицы (см. пример ниже). 
# В программе уже реализовано их чтение и сохранение в списке:

# Требуется проверить, не касаются ли единицы друг друга по горизонтали, вертикали и диагонали. 
# То есть, вокруг каждой единицы должны быть нули. 
# Если проверка проходит вывести на экран "ДА", иначе "НЕТ".



lst_in = [[1, 0, 0, 0, 0], 
          [0, 0, 1, 0, 1], 
          [0, 0, 0, 0, 0], 
          [0, 1, 0, 1, 0], 
          [0, 0, 0, 0, 0]]

lst_in = [[1, 0, 0, 0, 0], 
          [0, 1, 0, 0, 1], 
          [0, 0, 0, 0, 0], 
          [0, 1, 0, 0, 0], 
          [0, 0, 0, 1, 0]]



fl = False

# Направления для проверки: все 8 соседей
directions = [(-1, -1), (-1, 0), (-1, 1),
              (0, -1), (0, 1),
              (1, -1), (1, 0), (1, 1)]

for i in range(5):
    for j in range(5):
        if lst_in[i][j] == 1:  # Если нашли единицу
            # Проверяем соседей
            for direction in directions:
                ni, nj = i + direction[0], j + direction[1]
                # Проверяем, что сосед находится в пределах границ
                if 0 <= ni < 5 and 0 <= nj < 5:
                    if lst_in[ni][nj] == 1:
                        fl = True  # Найдена соседняя единица
                        break  # Прерываем проверку соседей
        if fl:  # Если нашли соседнюю единицу, выходим из внешнего цикла
            break
    if fl:  # Если нашли соседнюю единицу, выходим из внешнего цикла
        break

if fl:
    print("НЕТ")  # Найдена соседняя единица
else:
    print("ДА")  # Все единицы окружены нулями
    
                            # Аналог решения задания поиск соседей 1
import sys
s = sys.stdin.readlines()
lst_in = [list(map(int, x.strip().split())) for x in s]
for i in range(4):
    for j in range(4):
            if lst_in[i][j] + lst_in[i][j+1] + lst_in[i+1][j] + lst_in[i+1][j+1] > 1:
                print('НЕТ')
                sys.exit()
else:
    print('ДА')


                # Оперделить является ли этот двумерный список симметричным относительно главной диагонали

lst_in  = [[2, 3, 4, 5, 6], 
           [3, 2, 7, 8, 9], 
           [4, 7, 2, 0, 4], 
           [5, 8, 0, 2, 1], 
           [6, 9, 4, 1, 2]]

# lst_in  = [[2, 3, 4, 5, 6], 
#            [3, 2, 7, 8, 9], 
#            [7, 7, 2, 0, 4], 
#            [5, 8, 0, 2, 1], 
#            [6, 9, 4, 1, 2]]

fl = 'ДА'

for i in range(len(lst_in)):
    for j in range(i+1, len(lst_in)):
        if lst_in[i][j] != lst_in[j][i]:
            fl = "НЕТ"
            break

print(fl)


                                # Функция create_matrix должна возвращать квадратную матрицу размером size х size, на д
# иагонали которой располагаются числа от 1 до size. Все остальные элементы заполнены согласно параметрам up_fill и down_fill.


def create_matrix(size=3, up_fill=0, down_fill=0):
    matrix = [[0] * size for _ in range(size)]
    
    for i in range(size):
        for j in range(size):
            if i < j:
                matrix[i][j] = up_fill  # Заполняем элементы выше главной диагонали
            elif i > j:
                matrix[i][j] = down_fill  # Заполняем элементы ниже главной диагонали
            else:
                matrix[i][j] = i + 1  # Заполняем главную диагональ числами от 1 до size

    return matrix

