                                   # С помощью словаря выполните кэширование данных

# На вход программе поступают целые положительные числа. 
# Необходимо с помощью цикла реализовать их считывание, пока не встретится число 0. 
# В теле цикла для каждого прочитанного числа вычисляется квадратный корень (с точностью до сотых) 
# и значение выводится на экран (в столбик). 
# С помощью словаря выполните кэширование данных так, чтобы при повторном вводе того же 
# самого числа результат не вычислялся, а бралось ранее вычисленное значение (из словаря). 
# При этом на экране должно выводиться:
# значение из кэша: <число>

# Sample Input:
# 1
# 2
# 3
# 3
# 2
# 4
# 0
# Sample Output:
# 1.0
# 1.41
# 1.73
# значение из кэша: 1.73
# значение из кэша: 1.41
# 2.0

# решение 1
n = 1
d = {}
while n != 0:
    n = int(input())
    if n in d:
        print(f'значение из кэша: {d[n]}')
    else: 
        d[n]=round(n**0.5,2)
        print(d[n])


# решение 2
d={}
while n:=int(input()):  # Оператор `:=` присваивает целое число переменной `n`  ("оператор морж" (walrus operator))
                        # пока значение `n` != 0 или не приведено к `False`, цикл будет продолжаться
    if n in d:
        print(f'значение из кэша: {d[n]}')
    else: 
        d[n]=round(n**0.5,2)
        print(d[n])



                                                # Кеширование URL-адресов

# Тестовый веб-сервер возвращает HTML-страницы по URL-адресам (строкам). На вход программе поступают различные URL-адреса, 
# записанные каждое с новой строки. В программе уже реализовано считывание всех строк и сохранение их в виде списка:

# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Необходимо перебрать в цикле этот список с URL-адресами и если адрес появился (пришел) впервые, то на экране отобразить строку (без кавычек):

# "HTML-страница для адреса <URL-адрес>"

# и сохранить в словаре эту строку с ключом текущего URL-адреса. 
# Если же URL-адрес встречается (приходит) повторно (проверяется по ключам словаря), 
# то следует взять строку "HTML-страница для адреса <URL-адрес>" из этого словаря и вывести на экран 
# сообщение (без кавычек):

# "Взято из кэша: HTML-страница для адреса <URL-адрес>"

# Сообщения выводить каждое с новой строки.

# P.S. Подобные задачи на практике решаются через хэш-таблицы. 
# В Python словарь - это хэш-таблица. Скорость поиска ключа в нем выполняется очень быстро 
# (намного быстрее, чем в списке). Именно поэтому решать ее через список очень плохая практика.

# Sample Input:
# ustanovka-i-zapusk-yazyka
# ustanovka-i-poryadok-raboty-pycharm
# peremennyye-operator-prisvaivaniya-tipy-dannykh
# arifmeticheskiye-operatsii
# ustanovka-i-poryadok-raboty-pycharm

# Sample Output:
# HTML-страница для адреса ustanovka-i-zapusk-yazyka
# HTML-страница для адреса ustanovka-i-poryadok-raboty-pycharm
# HTML-страница для адреса peremennyye-operator-prisvaivaniya-tipy-dannykh
# HTML-страница для адреса arifmeticheskiye-operatsii
# Взято из кэша: HTML-страница для адреса ustanovka-i-poryadok-raboty-pycharm
lst_in = ['ustanovka-i-zapusk-yazyka', 'ustanovka-i-poryadok-raboty-pycharm', 'peremennyye-operator-prisvaivaniya-tipy-dannykh', 'arifmeticheskiye-operatsii', 'ustanovka-i-poryadok-raboty-pycharm']

# решение 1
d = {}
for i in lst_in:
    if i in d:
        print(f'Взято из кэша: {d[i]}')
    else:
        d[i] = f'HTML-страница для адреса {i}'
        print(f'HTML-страница для адреса {i}')

# решение 2 (рассмотреть правильно ли применяется сетдефолт)
d={}
for item in lst_in:
    if item in d:       
        print(f'Взято из кэша: HTML-страница для адреса {item}')
    else:
        d.setdefault(item, []).append(item)
        print(f'HTML-страница для адреса {item}')







